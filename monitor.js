const http = require('http');
const https = require('https');
const url = require('url');

/**
 * Network Monitor - C√¥ng c·ª• gi√°m s√°t hi·ªáu su·∫•t m·∫°ng
 * Theo d√µi v√† ph√¢n t√≠ch c√°c request HTTP/HTTPS
 */
class NetworkMonitor {
    constructor() {
        this.requests = [];
        this.isMonitoring = false;
        this.stats = {
            totalRequests: 0,
            successfulRequests: 0,
            failedRequests: 0,
            totalResponseTime: 0,
            averageResponseTime: 0
        };
    }

    /**
     * B·∫Øt ƒë·∫ßu gi√°m s√°t
     */
    start() {
        this.isMonitoring = true;
        this.requests = [];
        this.resetStats();
        console.log('üü¢ Network monitoring started at', new Date().toISOString());
    }

    /**
     * D·ª´ng gi√°m s√°t
     */
    stop() {
        this.isMonitoring = false;
        console.log('üî¥ Network monitoring stopped at', new Date().toISOString());
        this.generateReport();
    }

    /**
     * Reset th·ªëng k√™
     */
    resetStats() {
        this.stats = {
            totalRequests: 0,
            successfulRequests: 0,
            failedRequests: 0,
            totalResponseTime: 0,
            averageResponseTime: 0
        };
    }

    /**
     * Ghi l·∫°i m·ªôt request
     */
    logRequest(requestData) {
        if (!this.isMonitoring) return;

        const logEntry = {
            timestamp: new Date().toISOString(),
            method: requestData.method || 'GET',
            url: requestData.url,
            statusCode: requestData.statusCode,
            responseTime: requestData.responseTime,
            error: requestData.error || null,
            size: requestData.size || 0
        };

        this.requests.push(logEntry);
        this.updateStats(logEntry);
        this.displayLog(logEntry);
    }

    /**
     * C·∫≠p nh·∫≠t th·ªëng k√™
     */
    updateStats(logEntry) {
        this.stats.totalRequests++;
        this.stats.totalResponseTime += logEntry.responseTime;
        this.stats.averageResponseTime = Math.round(this.stats.totalResponseTime / this.stats.totalRequests);

        if (logEntry.statusCode >= 200 && logEntry.statusCode < 300) {
            this.stats.successfulRequests++;
        } else {
            this.stats.failedRequests++;
        }
    }

    /**
     * Hi·ªÉn th·ªã log entry
     */
    displayLog(logEntry) {
        const statusIcon = logEntry.statusCode >= 200 && logEntry.statusCode < 300 ? '‚úÖ' : '‚ùå';
        const errorText = logEntry.error ? ` (${logEntry.error})` : '';
        
        console.log(`[${logEntry.timestamp}] ${statusIcon} ${logEntry.method} ${logEntry.url} - ${logEntry.statusCode} (${logEntry.responseTime}ms)${errorText}`);
    }

    /**
     * T·∫°o b√°o c√°o t·ªïng h·ª£p
     */
    generateReport() {
        console.log('\n' + '='.repeat(80));
        console.log('üìä NETWORK MONITORING REPORT');
        console.log('='.repeat(80));
        console.log(`üìà Total Requests: ${this.stats.totalRequests}`);
        console.log(`‚úÖ Successful: ${this.stats.successfulRequests} (${Math.round(this.stats.successfulRequests / this.stats.totalRequests * 100)}%)`);
        console.log(`‚ùå Failed: ${this.stats.failedRequests} (${Math.round(this.stats.failedRequests / this.stats.totalRequests * 100)}%)`);
        console.log(`‚è±Ô∏è  Average Response Time: ${this.stats.averageResponseTime}ms`);
        console.log(`üèÅ Monitoring Duration: ${this.getMonitoringDuration()}`);
        
        // Ph√¢n t√≠ch chi ti·∫øt
        this.analyzePatterns();
        console.log('='.repeat(80));
    }

    /**
     * Ph√¢n t√≠ch patterns c·ªßa requests
     */
    analyzePatterns() {
        console.log('\nüìã DETAILED ANALYSIS:');
        
        // Ph√¢n t√≠ch theo method
        const methodStats = {};
        this.requests.forEach(req => {
            if (!methodStats[req.method]) {
                methodStats[req.method] = { count: 0, totalTime: 0 };
            }
            methodStats[req.method].count++;
            methodStats[req.method].totalTime += req.responseTime;
        });

        console.log('\nüîß By HTTP Method:');
        Object.keys(methodStats).forEach(method => {
            const stats = methodStats[method];
            const avgTime = Math.round(stats.totalTime / stats.count);
            console.log(`   ${method}: ${stats.count} requests, avg ${avgTime}ms`);
        });

        // Ph√¢n t√≠ch theo status code
        const statusStats = {};
        this.requests.forEach(req => {
            const statusRange = Math.floor(req.statusCode / 100) * 100;
            if (!statusStats[statusRange]) {
                statusStats[statusRange] = 0;
            }
            statusStats[statusRange]++;
        });

        console.log('\nüìä By Status Code:');
        Object.keys(statusStats).forEach(status => {
            console.log(`   ${status}xx: ${statusStats[status]} requests`);
        });

        // Top 5 slowest requests
        const slowestRequests = [...this.requests]
            .sort((a, b) => b.responseTime - a.responseTime)
            .slice(0, 5);

        console.log('\nüêå Top 5 Slowest Requests:');
        slowestRequests.forEach((req, index) => {
            console.log(`   ${index + 1}. ${req.method} ${req.url} - ${req.responseTime}ms`);
        });
    }

    /**
     * T√≠nh th·ªùi gian monitoring
     */
    getMonitoringDuration() {
        if (this.requests.length === 0) return '0ms';
        
        const first = new Date(this.requests[0].timestamp);
        const last = new Date(this.requests[this.requests.length - 1].timestamp);
        const duration = last - first;
        
        return `${duration}ms`;
    }

    /**
     * Th·ª±c hi·ªán request v√† theo d√µi
     */
    async monitoredRequest(options) {
        const startTime = Date.now();
        
        try {
            const response = await this.makeRequest(options);
            const responseTime = Date.now() - startTime;
            
            this.logRequest({
                method: options.method || 'GET',
                url: options.url,
                statusCode: response.statusCode,
                responseTime: responseTime,
                size: response.data ? response.data.length : 0
            });
            
            return response;
        } catch (error) {
            const responseTime = Date.now() - startTime;
            
            this.logRequest({
                method: options.method || 'GET',
                url: options.url,
                statusCode: 0,
                responseTime: responseTime,
                error: error.message
            });
            
            throw error;
        }
    }

    /**
     * Th·ª±c hi·ªán HTTP request
     */
    makeRequest(options) {
        return new Promise((resolve, reject) => {
            const parsedUrl = url.parse(options.url);
            const isHttps = parsedUrl.protocol === 'https:';
            const client = isHttps ? https : http;

            const requestOptions = {
                hostname: parsedUrl.hostname,
                port: parsedUrl.port || (isHttps ? 443 : 80),
                path: parsedUrl.path,
                method: options.method || 'GET',
                headers: options.headers || {}
            };

            const req = client.request(requestOptions, (res) => {
                let data = '';

                res.on('data', (chunk) => {
                    data += chunk;
                });

                res.on('end', () => {
                    resolve({
                        statusCode: res.statusCode,
                        statusMessage: res.statusMessage,
                        headers: res.headers,
                        data: data
                    });
                });
            });

            req.on('error', (error) => {
                reject(error);
            });

            if (options.data) {
                req.write(options.data);
            }

            req.end();
        });
    }
}

/**
 * Performance Benchmarking
 */
class PerformanceBenchmark {
    constructor(monitor) {
        this.monitor = monitor;
    }

    /**
     * Benchmark v·ªõi different file sizes
     */
    async benchmarkFileSizes() {
        console.log('\nüèÅ PERFORMANCE BENCHMARK - FILE SIZES');
        console.log('='.repeat(60));

        const testFiles = [
            { name: 'Small File', url: 'http://localhost:3000/', expectedSize: 'small' },
            { name: 'Medium File', url: 'http://localhost:3000/style.css', expectedSize: 'medium' },
            { name: 'Large File', url: 'http://localhost:3000/script.js', expectedSize: 'large' }
        ];

        for (const testFile of testFiles) {
            try {
                console.log(`\nüìÅ Testing ${testFile.name}...`);
                const startTime = Date.now();
                
                const response = await this.monitor.monitoredRequest({
                    url: testFile.url,
                    method: 'GET'
                });
                
                const endTime = Date.now();
                const responseTime = endTime - startTime;
                const fileSize = response.data ? response.data.length : 0;
                
                console.log(`   ‚úÖ ${testFile.name}: ${fileSize} bytes, ${responseTime}ms`);
                console.log(`   üìä Transfer rate: ${Math.round(fileSize / responseTime * 1000)} bytes/sec`);
                
                // T·∫°m d·ª´ng gi·ªØa c√°c tests
                await new Promise(resolve => setTimeout(resolve, 100));
                
            } catch (error) {
                console.log(`   ‚ùå ${testFile.name}: Error - ${error.message}`);
            }
        }
    }

    /**
     * Benchmark concurrent requests
     */
    async benchmarkConcurrentRequests() {
        console.log('\nüöÄ CONCURRENT REQUESTS BENCHMARK');
        console.log('='.repeat(60));

        const concurrencyLevels = [1, 5, 10];
        
        for (const concurrency of concurrencyLevels) {
            console.log(`\nüìä Testing ${concurrency} concurrent requests...`);
            
            const promises = [];
            const startTime = Date.now();
            
            for (let i = 0; i < concurrency; i++) {
                promises.push(this.monitor.monitoredRequest({
                    url: 'http://localhost:3000/api/health',
                    method: 'GET'
                }));
            }
            
            try {
                await Promise.all(promises);
                const endTime = Date.now();
                const totalTime = endTime - startTime;
                
                console.log(`   ‚úÖ Completed ${concurrency} requests in ${totalTime}ms`);
                console.log(`   üìà Average per request: ${Math.round(totalTime / concurrency)}ms`);
                console.log(`   üî• Requests per second: ${Math.round(concurrency / totalTime * 1000)}`);
                
            } catch (error) {
                console.log(`   ‚ùå Error in concurrent test: ${error.message}`);
            }
            
            // T·∫°m d·ª´ng gi·ªØa c√°c tests
            await new Promise(resolve => setTimeout(resolve, 500));
        }
    }
}

/**
 * Demo function
 */
async function runMonitoringDemo() {
    const monitor = new NetworkMonitor();
    const benchmark = new PerformanceBenchmark(monitor);
    
    console.log('üéØ STARTING NETWORK MONITORING DEMO');
    console.log('='.repeat(80));
    
    // B·∫Øt ƒë·∫ßu monitoring
    monitor.start();
    
    try {
        // Test c√°c endpoint c∆° b·∫£n
        console.log('\nüìã Testing basic endpoints...');
        await monitor.monitoredRequest({ url: 'http://localhost:3000/api/health' });
        await monitor.monitoredRequest({ url: 'http://localhost:3000/api/server-info' });
        await monitor.monitoredRequest({ url: 'http://localhost:3000/api/time' });
        
        // Test POST request
        console.log('\nüìã Testing POST request...');
        await monitor.monitoredRequest({
            url: 'http://localhost:3000/api/echo',
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            data: JSON.stringify({ test: 'monitoring', timestamp: new Date().toISOString() })
        });
        
        // Test error handling
        console.log('\nüìã Testing error handling...');
        try {
            await monitor.monitoredRequest({ url: 'http://localhost:3000/api/not-found' });
        } catch (error) {
            // Expected error
        }
        
        // Performance benchmarks
        await benchmark.benchmarkFileSizes();
        await benchmark.benchmarkConcurrentRequests();
        
    } catch (error) {
        console.error('‚ùå Demo error:', error.message);
    } finally {
        // D·ª´ng monitoring v√† t·∫°o b√°o c√°o
        monitor.stop();
    }
}

// Export classes
module.exports = {
    NetworkMonitor,
    PerformanceBenchmark
};

// Ch·∫°y demo n·∫øu file ƒë∆∞·ª£c execute tr·ª±c ti·∫øp
if (require.main === module) {
    // Ki·ªÉm tra xem server c√≥ ƒëang ch·∫°y kh√¥ng
    const http = require('http');
    
    const healthCheck = http.request({
        hostname: 'localhost',
        port: 3000,
        path: '/api/health',
        method: 'GET',
        timeout: 1000
    }, (res) => {
        console.log('‚úÖ Server is running, starting monitoring demo...\n');
        runMonitoringDemo().catch(console.error);
    });
    
    healthCheck.on('error', (error) => {
        console.log('‚ùå Server is not running on localhost:3000');
        console.log('üí° Please start the server first with: npm start');
        process.exit(1);
    });
    
    healthCheck.end();
}
